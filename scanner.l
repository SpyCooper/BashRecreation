%{
/*
 * Headstart for shell project made by Dr.Shawn Ostermann
 * Logic created by Josh Myers
 */

#include <string.h>
#include <ctype.h>
#include "parser.tab.h"
#include "bash.h"

/* some internal files generated by bison */
void yyerror(const char *s,...);
void yywarn(const char *s,...);
int yywrap(void) {return(1);}    // should be in library, but here it is for github

/* useful global variables */
extern int debug;

/* Everything up to the funny characters on the next line */
/* goes directly into the lex.yy.c file */
%}



/* The rest of this after the '%%' is lex rules */
%%

[ \t]+	        { }  /* Just ignore white space */

"\n" 	{ return(EOLN); } /* return EOLN token */

"<"	{
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw an infile '%s'\n", yytext);
    }
    return(INFILE); /* return INFILE token */
}

">"	{ 
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw an outfile '%s'\n", yytext);
    }
    /* return OUTFILE token */
    return(OUTFILE);
}

">>" {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw an appended outfile '%s'\n", yytext);
    }
    /* return OUTFILE_APPEND token */
    return(OUTFILE_APPEND);
}

"2>" {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw an errorfile '%s'\n", yytext);
    }
    /* return ERRFILE token */
    return(ERRFILE);
}

"2>>" {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner an appended errorfile '%s'\n", yytext);
    }
    /* return ERRFILE_APPEND token */
    return(ERRFILE_APPEND);
}

"|"	{
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner a pipe '%s'\n", yytext);
    }
    // return the PIPE token
    return(PIPE);
}

"<<"[<]+ {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw 3 or more < '%s'\n", yytext);
    }
    /* returns an error for anything more than 2 << */
    yyerror("syntax error");
}

">>"[>]+ {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw 3 or more > '%s'\n", yytext);
    }
    /* returns an error for anything more than 2 >> */
    yyerror("syntax error");
}

"&&" {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw an && '%s'\n", yytext);
    }
    // return the AND token
    return(AND);
}

"||" {
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw an || '%s'\n", yytext);
    }
    // return the OR token
    return(OR);
}


%{
/* this rule will get you "started" with the WORD token.  As you work on the project,
   you'll need to update it to support other characters too... */
%}

[a-zA-Z_][a-zA-Z_0-9]*[ \t]*"="[ \t]*[a-zA-Z_0-9/\:.&?,\-/(){}+~\[\];:?@$#%^$&*!<>]+ {
    // set the environment variable
    set_environment_variable(yytext);
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw a VARIABLE '%s'\n", yytext);
    }
}

[a-zA-Z_][a-zA-Z_0-9]*[ \t]*"="[ \t]*\"[a-zA-Z_0-9/\:. &?,\-/(){}+~\[\];:?@$#%^$&*!<>]*\" {
    // set the environment variable
    set_environment_variable(yytext);
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw a VARIABLE '%s'\n", yytext);
    }
}

[a-zA-Z_][a-zA-Z_0-9]*[ \t]*"="[ \t]*\'[a-zA-Z_0-9/\:. &?,\-/(){}+~\[\];:?@$#%^$&*!<>]+\' {
    // set the environment variable
    set_environment_variable(yytext);
    // if debugging, print the debugging text
    if (debug)
    {
        printf("scanner saw a VARIABLE '%s'\n", yytext);
    }
}


([a-zA-Z_.0-9&?,\-/(){}+~\[\];:?@#%^$*!]+|\"[^\"]+\"|\'[^\']+\') {
    // if debugging, print the word
    if (debug)
    {
        printf("scanner saw WORD '%s'\n", yytext);
    }
    // if the word is a string, remove the quotes
    if (yytext[0] == '"' || yytext[0] == '\'')
    {
        int check = 0;
        for (int i = 0; i < yyleng; i++)
        {
            if (yytext[i] == '$')
            {
                check = 1;
            }
        }
        if (check == 1)
        {
            yylval.string = strdup(yytext);
        }
        else
        {
            yylval.string = strndup(yytext+1, yyleng-2);
        }
    }
    // if the word is not a string, make a copy of the word
    else
    {
        yylval.string = strdup(yytext);
    }
    // return the WORD token
    return(WORD);
}


%{
/* you need rules for the other reserved characters below */

/* you will also need a rule that returns "strings" as WORDS */
%}



.		{
    /* if we haven't matched anything yet, then it's illegal */
    fprintf(stdout, "scanner: Bad character '%c'\n", *yytext);
}


%%
