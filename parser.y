%{
/*
 * Headstart for shell project made by Dr.Shawn Ostermann
 * Logic created by Josh Myers
 */
 
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "bash.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// data structure to hold a linked list of arguments for a command
struct args {
    char *arg;
    struct args *next;
};

// data structure to hold a linked list of redirections for a command
struct redirs {
    int redir_token;
	char *filename;
    struct redirs *next;
};


/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;


int arg_count = 0;
bool error = false;

%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
    struct args *pargs;
    struct redirs *predir;
    int number;
}



%token EOLN PIPE VAR
%token INFILE					// standard input redirection
%token OUTFILE OUTFILE_APPEND	// standard output redirection
%token ERRFILE ERRFILE_APPEND	// standard error redirection
%token <string> WORD
%token AND
%token OR

%type <pcmd> line cmd	// main datatype from bash.h
%type <pargs> optargs arg
%type <predir> optredirs redir
  

%% 	/* beginning of the parsing rules	*/
input	: lines
	|
  	;

lines	: oneline
	| oneline lines
	;

oneline : line eoln
		{
			// if error were not found, run doline()
			if(synerrors == 0)
			{
				if (debug)
				{
					printf("Line %d had no errors ", lines);
				}
				doline($1);
			}
			else
			{
				if(debug)
					printf("An error was found on line %d\n", lines);
			}
			// reset the error count
			synerrors = 0;
		}
 	| eoln	/* blank line, do nothing */
	| error eoln
		/* if we got an error on the line, don't call the C program */
	;

eoln	: EOLN
		{ ++lines; arg_count = 0; error = false;}
	;


// you need to finish the rest of this...
line	: cmd
		{
			// cmd is a datastructure, pass it upstream
			$$ = $1;
		}
  	| cmd PIPE line
		{
			// pass the cmd upstream
			$$ = $1;
			// check if the outfile is already set
			if ($$->outfile != NULL)
			{
				yyerror("illegal redirection");
			}
			// set the cmd's outfile to be the pipe
			$$->outfile = "|";
			if (debug)
			{
				printf("scanner saw PIPE at line %d\n", lines);
			}

			// set the next command to be the next command
			$$->next = $3;
			// check if the next command's infile is already set
			if ($1->next->infile != NULL)
			{
				yyerror("illegal redirection");
			}
			// set the next command's infile to be the pipe
			$1->next->infile = "|";
		}
	|
	cmd AND line
		{
			// pass the cmd upstream
			$$ = $1;
			// check if the cmd is true
			if (strcmp($$->command, "false") != 0)
			{
				// remove the command and run the next command
				$$ = $3;
			}
		}
	|
	cmd OR line
		{
			// pass the cmd upstream
			$$ = $1;
			// check if the cmd is false
			if (strcmp($$->command, "true") != 0)
			{
				// free the previous command
				free($$);
				// remove the command and run the next command
				$$ = $3;
			}
		}
  	;

// FINISH THIS
cmd	: WORD optargs optredirs
		{ 
			// make and fill node of type "struct command "
			struct command *pcmd = (struct command *)MallocZ(sizeof(struct command));
			// set the command to be the first argument
			pcmd->command = $1;
			// set the next command to be NULL
			pcmd->next = NULL;
			// count the number of arguments and set them
			pcmd->argc = 1;
			pcmd->argv[0] = $1;
			while ($2 != NULL)
			{
				pcmd->argv[pcmd->argc] = $2->arg;
				pcmd->argc++;
				$2 = $2->next;
			}
			// set the default redirections
			pcmd->infile = NULL;
			pcmd->outfile = NULL;
			pcmd->output_append = 0;
			pcmd->errfile = NULL;
			pcmd->error_append = 0;
			// sets the redirect tokens
			while ($3 != NULL)
			{
				// check if the redirection type is infile
				if ($3->redir_token == INFILE)
				{
					// check if the infile is already set
					if (pcmd->infile != NULL)
					{
						yyerror("illegal redirection");
					}
					// set the infile to the filename
					pcmd->infile = $3->filename;
				}
				// check if the redirection type is outfile
				else if ($3->redir_token == OUTFILE)
				{
					// check if the outfile is already set
					if (pcmd->outfile != NULL)
					{
						yyerror("illegal redirection");
					}
					// set the outfile to the filename
					pcmd->outfile = $3->filename;
				}
				// check if the redirection type is outfile_append
				else if ($3->redir_token == OUTFILE_APPEND)
				{
					// check if the outfile is already set
					if (pcmd->outfile != NULL)
					{
						yyerror("illegal redirection");
					}
					// set the outfile to the filename
					pcmd->outfile = $3->filename;
					// set the output_append flag
					pcmd->output_append = 1;
				}
				// check if the redirection type is errfile
				else if ($3->redir_token == ERRFILE)
				{
					// check if the errfile is already set
					if (pcmd->errfile != NULL)
					{
						yyerror("illegal redirection");
					}
					// set the errfile to the filename
					pcmd->errfile = $3->filename;
				}
				// check if the redirection type is errfile_append
				else if ($3->redir_token == ERRFILE_APPEND)
				{
					// check if the errfile is already set
					if (pcmd->errfile != NULL)
					{
						yyerror("illegal redirection");
					}
					// set the errfile to the filename
					pcmd->errfile = $3->filename;
					// set the error_append flag
					pcmd->error_append = 1;
				}
				// move to the next redirection
				$3 = $3->next;
			}
			// pass the data structure upstream
			$$ = pcmd;
		}
	;

// FINISH THIS
// these 2 rules are for "optional arguments".  They should allow one or more "arg"s
// and assemble them into a linked list of type "struct args" and return it upstead
optargs : arg optargs
			{
				// make a node for type "struct args"
				struct args *pargs = (struct args *)MallocZ(sizeof(struct args));
				// set the argument to be the first argument
				pargs->arg = $1->arg;
				// set the next argument to be the next argument
				pargs->next = $2;
				// pass the data structure upstream
				$$ = pargs;
			}
		|	
			{

				$$ = NULL; // no more args 
			}
		;
arg		: WORD
		{
			arg_count = arg_count + 1;
			if (error == false && arg_count > 100)
			{
				yyerror("Argument list too long");
				error = true;
			}
			else
			{
				// make a node for type "struct args"
				struct args *pargs = (struct args *)MallocZ(sizeof(struct args));
				// set the argument to be the first argument
				pargs->arg = $1;
				// set the next argument to be NULL
				pargs->next = NULL;
				// pass the data structure upstream
				$$ = pargs;
			}
		}
		;


// FINISH THIS
// these 2 rules are for "optional redirection".  They should  allow one or more sets of 
// redirection commands from the rule "redir"
// and assemble them into a linked list of type "struct redir" and return it upstead
optredirs : redir optredirs
			{ 
				// creates a redirect object
				struct redirs *redirect =(struct redirs *)MallocZ(sizeof(struct command));
				// sets the redirection token
				redirect->redir_token = $1->redir_token;
				// sets the filename
				redirect->filename = $1->filename;
				// sets the next redirection
				redirect->next = $2;
				// pass the data structure upstream
				$$ = redirect;
			}
		|
			{ 
				$$ = NULL; // no more redirection 
			}
		;
// determines the type of redirection		
redir	: INFILE WORD
		{ 
			// make a node for type "struct redirs"
			struct redirs *redirect = (struct redirs *)MallocZ(sizeof(struct redirs));
			// set the redirection token
			redirect->redir_token = INFILE;
			// set the filename
			redirect->filename = $2;
			// set the next redirection to be NULL
			redirect->next = NULL;
			// pass the data structure upstream
			$$ = redirect;
		}
		| OUTFILE WORD
		{ 
			// make a node for type "struct redirs"
			struct redirs *redirect = (struct redirs *)MallocZ(sizeof(struct redirs));
			// set the redirection token
			redirect->redir_token = OUTFILE;
			// set the filename
			redirect->filename = $2;
			// set the next redirection to be NULL
			redirect->next = NULL;
			// pass the data structure upstream
			$$ = redirect;
		}
		| ERRFILE WORD
		{ 
			// make a node for type "struct redirs"
			struct redirs *redirect = (struct redirs *)MallocZ(sizeof(struct redirs));
			// set the redirection token
			redirect->redir_token = ERRFILE;
			// set the filename
			redirect->filename = $2;
			// set the next redirection to be NULL
			redirect->next = NULL;
			// pass the data structure upstream
			$$ = redirect;
		}
		| OUTFILE_APPEND WORD
		{ 
			// make a node for type "struct redirs"
			struct redirs *redirect = (struct redirs *)MallocZ(sizeof(struct redirs));
			// set the redirection token
			redirect->redir_token = OUTFILE_APPEND;
			// set the filename
			redirect->filename = $2;
			// set the next redirection to be NULL
			redirect->next = NULL;
			// pass the data structure upstream
			$$ = redirect;
		}
		| ERRFILE_APPEND WORD
		{ 
			// make a node for type "struct redirs"
			struct redirs *redirect = (struct redirs *)MallocZ(sizeof(struct redirs));
			// set the redirection token
			redirect->redir_token = ERRFILE_APPEND;
			// set the filename
			redirect->filename = $2;
			// set the next redirection to be NULL
			redirect->next = NULL;
			// pass the data structure upstream
			$$ = redirect;
		}
		;

%%

void
yyerror(const char *error_string, ...)
{
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;

	// print the error message with the line number
    fprintf(f,"Error on line %d: ", lines+1);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}

// You should use this routine instead of malloc() to avoid some memory problems
#include <stdlib.h>
#include <string.h>
void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);  // use the real routine
    if (ptr == NULL)
	{
	    perror ("MallocZ failed, fatal\n");
	    exit (66);
	}

	// initialize the space to all zeroes
    memset (ptr, '\00', nbytes);

    return (ptr);
}
